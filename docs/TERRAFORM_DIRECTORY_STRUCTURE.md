# Terraform Directory Structure & Workflow

## Current Directory Layout

```
k8s_framework/
├── terraform/                           ← YOUR EXISTING TERRAFORM (Manual/CI)
│   ├── main.tf                          
│   ├── providers.tf
│   ├── variables.tf
│   ├── modules/                         ← Reusable modules
│   │   ├── azure/
│   │   ├── aws/
│   │   └── gcp/
│   ├── environments/                    ← Where Backstage generates NEW projects
│   │   ├── dev/
│   │   │   └── payment-api/            ← Generated by Backstage (example)
│   │   │       ├── main.tf
│   │   │       ├── variables.tf
│   │   │       └── resources.tf
│   │   ├── stage/
│   │   └── prod/
│   └── backend/
│       └── azure.tf
│
└── backstage-hexaware/examples/templates/terraform-aks-service/
    └── content/                         ← TEMPLATE ONLY (Cookie Cutter)
        ├── main.tf                      ← Has ${{ values.* }} placeholders
        ├── variables.tf                 ← NOT executed directly
        └── resources.tf                 ← Copied and customized by Backstage

```

## Two Workflows

### Workflow 1: Manual/CI for Existing Infrastructure

```
Developer edits terraform/*.tf manually
         ↓
Commits to Git
         ↓
GitHub Actions runs from terraform/ root
         ↓
Terraform applies your existing infrastructure
```

**CI Pipeline (.github/workflows/terraform-apply.yml):**
```yaml
defaults:
  run:
    working-directory: ./terraform  # ← Runs from YOUR terraform directory
```

### Workflow 2: Backstage Self-Service (NEW Services)

```
Developer opens http://localhost:3000/create
         ↓
Selects "Deploy AKS Service with Terraform"
         ↓
Fills form: serviceName="payment-api", env="dev"
         ↓
Backstage copies files from templates/.../content/
         ↓
Replaces ${{ values.serviceName }} with "payment-api"
         ↓
Generates new Terraform in terraform/environments/dev/payment-api/
         ↓
Creates Pull Request
         ↓
GitHub Actions runs terraform plan from that NEW directory
         ↓
Merge → terraform apply creates new AKS cluster
```

## Question: What Gets Executed?

### ❌ NEVER Executed Directly:
- `backstage-hexaware/examples/templates/.../content/`
- These are templates with `${{ values.* }}` placeholders
- Just a cookie cutter/boilerplate

### ✅ Executed by CI:
1. **Your existing code:** `terraform/` root
2. **Backstage-generated code:** `terraform/environments/<env>/<service>/`

## Example: Deploy "payment-api" via Backstage

### Step 1: User fills form
```
Service Name: payment-api
Environment: dev
Location: eastus
Node Count: 3
```

### Step 2: Backstage generates (from template)
```
terraform/environments/dev/payment-api/
├── main.tf           ← ${{ values.serviceName }} becomes "payment-api"
├── variables.tf      ← ${{ values.nodeCount }} becomes 3
├── resources.tf      ← ${{ values.location }} becomes "eastus"
└── catalog-info.yaml
```

### Step 3: CI Pipeline runs
```yaml
# GitHub Actions workflow
- name: Terraform Apply
  run: terraform apply
  working-directory: ./terraform/environments/dev/payment-api  # ← Generated code
```

## Your Azure Credentials

Add these as **GitHub Secrets** (NOT in code):

```
Name: AZURE_CREDENTIALS
Value: {
  "clientId": "YOUR_CLIENT_ID",
  "clientSecret": "YOUR_CLIENT_SECRET",
  "subscriptionId": "YOUR_SUBSCRIPTION_ID",
  "tenantId": "YOUR_TENANT_ID"
}
```

**Note:** The secret values are already configured in your GitHub repository.

**Add at:** https://github.com/a1234567yadav-creator/k8s_framework/settings/secrets/actions/new

## GitHub Actions Workflow

When code is in `terraform/` or `terraform/environments/**`:

```yaml
# .github/workflows/terraform-apply.yml
on:
  push:
    branches: [main]
    paths:
      - 'terraform/**'     # ← Triggers on ANY terraform/ changes

jobs:
  terraform-apply:
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform  # ← Change this per project
```

## Which Approach Should You Use?

### Option A: Keep Manual Workflow
- Edit `terraform/*.tf` manually
- Commit to Git
- CI/CD applies changes
- **Use for:** Existing infrastructure

### Option B: Enable Backstage Self-Service
- Developers use UI to create NEW clusters
- Backstage generates Terraform code
- CI/CD applies generated code
- **Use for:** New services, developer self-service

### Option C: Hybrid (Recommended)
- **Existing infra:** Manual edits to `terraform/`
- **New services:** Backstage templates → `terraform/environments/`
- Both go through same CI/CD pipeline

## Key Points

1. **Template files are NOT executed** - they're just a starting point
2. **CI runs from Git** - code must be committed first
3. **Backstage generates real Terraform** - outputs go to `terraform/environments/`
4. **One CI pipeline** - works for both manual and generated code
5. **Templates save time** - no copy/paste, consistent naming, validation

## Testing the Flow

### Test Backstage Template:
1. Open http://localhost:3000/create/edit
2. Paste the template YAML
3. Preview shows form with parameters
4. Fill form → See generated files (preview only)

### Test CI Pipeline:
1. Create test file: `terraform/test.txt`
2. Commit and push
3. Check GitHub Actions runs at: https://github.com/a1234567yadav-creator/k8s_framework/actions
4. Verify workflow triggered by `terraform/**` path

## Summary

- **Template content/** = Cookie cutter (not executed)
- **terraform/** = Your real code (executed by CI)
- **terraform/environments/** = Backstage output (executed by CI)
- **GitHub Actions** = Runs terraform from Git, not from templates

The templates just save you from writing boilerplate manually. The CI pipeline only runs code that's committed to Git in the `terraform/` directory.
